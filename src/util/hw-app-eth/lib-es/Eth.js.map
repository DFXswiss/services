{"version":3,"sources":["../src/Eth.js"],"names":["splitPath","foreach","log","EthAppPleaseEnableContractData","BigNumber","ethers","byContractAddress","getInfosForContractMethod","starkQuantizationTypeMap","eth","erc20","erc721","erc20mintable","erc721mintable","hexBuffer","str","Buffer","from","startsWith","slice","maybeHexBuffer","remapTransactionRelatedErrors","e","statusCode","Eth","constructor","transport","scrambleKey","decorateAppAPIMethods","getAddress","path","boolDisplay","boolChaincode","paths","buffer","alloc","length","forEach","element","index","writeUInt32BE","send","then","response","result","publicKeyLength","addressLength","publicKey","toString","address","chainCode","provideERC20TokenInformation","data","signTransaction","rawTxHex","offset","rawTx","toSend","rlpTx","utils","RLP","decode","map","hex","rlpOffset","chainIdPrefix","rlpVrs","encode","sizeOfListLen","chainIdSrc","chainIdBuf","copy","readUInt32BE","maxChunkSize","chunkSize","push","decodedTx","to","provideForContract","erc20Info","contractAddress","ticker","selector","substring","infos","plugin","payload","signature","erc20OfInterest","abi","setExternalPlugin","contract","Interface","args","parseTransaction","split","reduce","value","seg","Array","isArray","i","apduResponse","v","r","s","getAppConfiguration","arbitraryDataEnabled","erc20ProvisioningNecessary","starkEnabled","starkv2Supported","version","signPersonalMessage","messageHex","message","signEIP712HashedMessage","domainSeparatorHex","hashStructMessageHex","domainSeparator","hashStruct","starkGetPublicKey","starkSignOrder","sourceTokenAddress","sourceQuantization","destinationTokenAddress","destinationQuantization","sourceVault","destinationVault","amountSell","amountBuy","nonce","timestamp","sourceTokenAddressHex","destinationTokenAddressHex","padStart","starkSignOrder_v2","sourceQuantizationType","sourceMintableBlobOrTokenId","destinationQuantizationType","destinationMintableBlobOrTokenId","Error","starkSignTransfer","transferTokenAddress","transferQuantization","targetPublicKey","amountTransfer","transferTokenAddressHex","targetPublicKeyHex","starkSignTransfer_v2","transferQuantizationType","transferMintableBlobOrTokenId","conditionalTransferAddress","conditionalTransferFact","conditionalTransferAddressHex","starkProvideQuantum","operationContract","operationQuantization","operationContractHex","starkProvideQuantum_v2","operationQuantizationType","operationMintableBlobOrTokenId","starkUnsafeSign","hash","hashHex","eth2GetPublicKey","eth2SetWithdrawalIndex","withdrawalIndex","pluginName","payloadBuffer","signatureBuffer","concat"],"mappings":"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","sourcesContent":["/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//@flow\n\n// FIXME drop:\nimport { splitPath, foreach } from \"./utils\";\nimport { log } from \"@ledgerhq/logs\";\nimport { EthAppPleaseEnableContractData } from \"@ledgerhq/errors\";\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport { BigNumber } from \"bignumber.js\";\nimport { ethers } from \"ethers\";\nimport { byContractAddress } from \"./erc20\";\nimport { getInfosForContractMethod } from \"./contracts\";\n\nexport type StarkQuantizationType =\n  | \"eth\"\n  | \"erc20\"\n  | \"erc721\"\n  | \"erc20mintable\"\n  | \"erc721mintable\";\n\nconst starkQuantizationTypeMap = {\n  eth: 1,\n  erc20: 2,\n  erc721: 3,\n  erc20mintable: 4,\n  erc721mintable: 5,\n};\n\nfunction hexBuffer(str: string): Buffer {\n  return Buffer.from(str.startsWith(\"0x\") ? str.slice(2) : str, \"hex\");\n}\n\nfunction maybeHexBuffer(str: ?string): ?Buffer {\n  if (!str) return null;\n  return hexBuffer(str);\n}\n\nconst remapTransactionRelatedErrors = (e) => {\n  if (e && e.statusCode === 0x6a80) {\n    return new EthAppPleaseEnableContractData(\n      \"Please enable Contract data on the Ethereum app Settings\"\n    );\n  }\n  return e;\n};\n\n/**\n * Ethereum API\n *\n * @example\n * import Eth from \"@ledgerhq/hw-app-eth\";\n * const eth = new Eth(transport)\n */\nexport default class Eth {\n  transport: Transport<*>;\n\n  constructor(transport: Transport<*>, scrambleKey: string = \"w0w\") {\n    this.transport = transport;\n    transport.decorateAppAPIMethods(\n      this,\n      [\n        \"getAddress\",\n        \"provideERC20TokenInformation\",\n        \"signTransaction\",\n        \"signPersonalMessage\",\n        \"getAppConfiguration\",\n        \"signEIP712HashedMessage\",\n        \"starkGetPublicKey\",\n        \"starkSignOrder\",\n        \"starkSignOrder_v2\",\n        \"starkSignTransfer\",\n        \"starkSignTransfer_v2\",\n        \"starkProvideQuantum\",\n        \"starkProvideQuantum_v2\",\n        \"starkUnsafeSign\",\n        \"eth2GetPublicKey\",\n        \"eth2SetWithdrawalIndex\",\n        \"setExternalPlugin\",\n      ],\n      scrambleKey\n    );\n  }\n\n  /**\n   * get Ethereum address for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @option boolChaincode optionally enable or not the chaincode request\n   * @return an object with a publicKey, address and (optionally) chainCode\n   * @example\n   * eth.getAddress(\"44'/60'/0'/0/0\").then(o => o.address)\n   */\n  getAddress(\n    path: string,\n    boolDisplay?: boolean,\n    boolChaincode?: boolean\n  ): Promise<{\n    publicKey: string,\n    address: string,\n    chainCode?: string,\n  }> {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport\n      .send(\n        0xe0,\n        0x02,\n        boolDisplay ? 0x01 : 0x00,\n        boolChaincode ? 0x01 : 0x00,\n        buffer\n      )\n      .then((response) => {\n        let result = {};\n        let publicKeyLength = response[0];\n        let addressLength = response[1 + publicKeyLength];\n        result.publicKey = response\n          .slice(1, 1 + publicKeyLength)\n          .toString(\"hex\");\n        result.address =\n          \"0x\" +\n          response\n            .slice(\n              1 + publicKeyLength + 1,\n              1 + publicKeyLength + 1 + addressLength\n            )\n            .toString(\"ascii\");\n        if (boolChaincode) {\n          result.chainCode = response\n            .slice(\n              1 + publicKeyLength + 1 + addressLength,\n              1 + publicKeyLength + 1 + addressLength + 32\n            )\n            .toString(\"hex\");\n        }\n        return result;\n      });\n  }\n\n  /**\n   * This commands provides a trusted description of an ERC 20 token\n   * to associate a contract address with a ticker and number of decimals.\n   *\n   * It shall be run immediately before performing a transaction involving a contract\n   * calling this contract address to display the proper token information to the user if necessary.\n   *\n   * @param {*} info: a blob from \"erc20.js\" utilities that contains all token information.\n   *\n   * @example\n   * import { byContractAddress } from \"@ledgerhq/hw-app-eth/erc20\"\n   * const zrxInfo = byContractAddress(\"0xe41d2489571d322189246dafa5ebde1f4699f498\")\n   * if (zrxInfo) await appEth.provideERC20TokenInformation(zrxInfo)\n   * const signed = await appEth.signTransaction(path, rawTxHex)\n   */\n  provideERC20TokenInformation({ data }: { data: Buffer }): Promise<boolean> {\n    return provideERC20TokenInformation(this.transport, data);\n  }\n\n  /**\n   * You can sign a transaction and retrieve v, r, s given the raw transaction and the BIP 32 path of the account to sign\n   * @example\n   eth.signTransaction(\"44'/60'/0'/0/0\", \"e8018504e3b292008252089428ee52a8f3d6e5d15f8b131996950d7f296c7952872bd72a2487400080\").then(result => ...)\n   */\n  async signTransaction(\n    path: string,\n    rawTxHex: string\n  ): Promise<{\n    s: string,\n    v: string,\n    r: string,\n  }> {\n    let paths = splitPath(path);\n    let offset = 0;\n    let rawTx = Buffer.from(rawTxHex, \"hex\");\n    let toSend = [];\n    let response;\n    // Check if the TX is encoded following EIP 155\n    let rlpTx = ethers.utils.RLP.decode(\"0x\" + rawTxHex).map((hex) =>\n      Buffer.from(hex.slice(2), \"hex\")\n    );\n\n    let rlpOffset = 0;\n    let chainIdPrefix = \"\";\n    if (rlpTx.length > 6) {\n      let rlpVrs = Buffer.from(\n        ethers.utils.RLP.encode(rlpTx.slice(-3)).slice(2),\n        \"hex\"\n      );\n\n      rlpOffset = rawTx.length - (rlpVrs.length - 1);\n\n      // First byte > 0xf7 means the length of the list length doesn't fit in a single byte.\n      if (rlpVrs[0] > 0xf7) {\n        // Increment rlpOffset to account for that extra byte.\n        rlpOffset++;\n\n        // Compute size of the list length.\n        let sizeOfListLen = rlpVrs[0] - 0xf7;\n\n        // Increase rlpOffset by the size of the list length.\n        rlpOffset += sizeOfListLen - 1;\n      }\n\n      const chainIdSrc = rlpTx[6];\n      const chainIdBuf = Buffer.alloc(4);\n      chainIdSrc.copy(chainIdBuf, 4 - chainIdSrc.length);\n      chainIdPrefix = (chainIdBuf.readUInt32BE(0) * 2 + 35)\n        .toString(16)\n        .slice(0, -2); // Drop the low byte, that comes from the ledger.\n      if (chainIdPrefix.length % 2 === 1) {\n        chainIdPrefix = \"0\" + chainIdPrefix;\n      }\n    }\n    while (offset !== rawTx.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 : 150;\n      let chunkSize =\n        offset + maxChunkSize > rawTx.length\n          ? rawTx.length - offset\n          : maxChunkSize;\n      if (rlpOffset != 0 && offset + chunkSize == rlpOffset) {\n        // Make sure that the chunk doesn't end right on the EIP 155 marker if set\n        chunkSize--;\n      }\n      let buffer = Buffer.alloc(\n        offset === 0 ? 1 + paths.length * 4 + chunkSize : chunkSize\n      );\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        rawTx.copy(buffer, 1 + 4 * paths.length, offset, offset + chunkSize);\n      } else {\n        rawTx.copy(buffer, 0, offset, offset + chunkSize);\n      }\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n\n    rlpTx = ethers.utils.RLP.decode(\"0x\" + rawTxHex);\n\n    const decodedTx = {\n      data: rlpTx[5],\n      to: rlpTx[3],\n    };\n    const provideForContract = async (address) => {\n      const erc20Info = byContractAddress(address);\n      if (erc20Info) {\n        log(\n          \"ethereum\",\n          \"loading erc20token info for \" +\n            erc20Info.contractAddress +\n            \" (\" +\n            erc20Info.ticker +\n            \")\"\n        );\n        await provideERC20TokenInformation(this.transport, erc20Info.data);\n      }\n    };\n\n    if (decodedTx.data.length >= 10) {\n      const selector = decodedTx.data.substring(0, 10);\n      const infos = getInfosForContractMethod(decodedTx.to, selector);\n\n      if (infos) {\n        let { plugin, payload, signature, erc20OfInterest, abi } = infos;\n\n        if (plugin) {\n          log(\"ethereum\", \"loading plugin for \" + selector);\n          await setExternalPlugin(this.transport, payload, signature);\n        }\n\n        if (erc20OfInterest && erc20OfInterest.length && abi) {\n          const contract = new ethers.utils.Interface(abi);\n          const args = contract.parseTransaction(decodedTx).args;\n\n          for (path of erc20OfInterest) {\n            const address = path.split(\".\").reduce((value, seg) => {\n              if (seg === \"-1\" && Array.isArray(value)) {\n                return value[value.length - 1];\n              }\n              return value[seg];\n            }, args);\n            await provideForContract(address);\n          }\n        }\n      } else {\n        log(\"ethereum\", \"no infos for selector \" + selector);\n      }\n\n      await provideForContract(decodedTx.to);\n    }\n\n    return foreach(toSend, (data, i) =>\n      this.transport\n        .send(0xe0, 0x04, i === 0 ? 0x00 : 0x80, 0x00, data)\n        .then((apduResponse) => {\n          response = apduResponse;\n        })\n    ).then(\n      () => {\n        const v = chainIdPrefix + response.slice(0, 1).toString(\"hex\");\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { v, r, s };\n      },\n      (e) => {\n        throw remapTransactionRelatedErrors(e);\n      }\n    );\n  }\n\n  /**\n   */\n  getAppConfiguration(): Promise<{\n    arbitraryDataEnabled: number,\n    erc20ProvisioningNecessary: number,\n    starkEnabled: number,\n    starkv2Supported: number,\n    version: string,\n  }> {\n    return this.transport.send(0xe0, 0x06, 0x00, 0x00).then((response) => {\n      let result = {};\n      result.arbitraryDataEnabled = response[0] & 0x01;\n      result.erc20ProvisioningNecessary = response[0] & 0x02;\n      result.starkEnabled = response[0] & 0x04;\n      result.starkv2Supported = response[0] & 0x08;\n      result.version = \"\" + response[1] + \".\" + response[2] + \".\" + response[3];\n      return result;\n    });\n  }\n\n  /**\n  * You can sign a message according to eth_sign RPC call and retrieve v, r, s given the message and the BIP 32 path of the account to sign.\n  * @example\neth.signPersonalMessage(\"44'/60'/0'/0/0\", Buffer.from(\"test\").toString(\"hex\")).then(result => {\n  var v = result['v'] - 27;\n  v = v.toString(16);\n  if (v.length < 2) {\n    v = \"0\" + v;\n  }\n  console.log(\"Signature 0x\" + result['r'] + result['s'] + v);\n})\n   */\n  signPersonalMessage(\n    path: string,\n    messageHex: string\n  ): Promise<{\n    v: number,\n    s: string,\n    r: string,\n  }> {\n    let paths = splitPath(path);\n    let offset = 0;\n    let message = Buffer.from(messageHex, \"hex\");\n    let toSend = [];\n    let response;\n    while (offset !== message.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 - 4 : 150;\n      let chunkSize =\n        offset + maxChunkSize > message.length\n          ? message.length - offset\n          : maxChunkSize;\n      let buffer = Buffer.alloc(\n        offset === 0 ? 1 + paths.length * 4 + 4 + chunkSize : chunkSize\n      );\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        buffer.writeUInt32BE(message.length, 1 + 4 * paths.length);\n        message.copy(\n          buffer,\n          1 + 4 * paths.length + 4,\n          offset,\n          offset + chunkSize\n        );\n      } else {\n        message.copy(buffer, 0, offset, offset + chunkSize);\n      }\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n    return foreach(toSend, (data, i) =>\n      this.transport\n        .send(0xe0, 0x08, i === 0 ? 0x00 : 0x80, 0x00, data)\n        .then((apduResponse) => {\n          response = apduResponse;\n        })\n    ).then(() => {\n      const v = response[0];\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return { v, r, s };\n    });\n  }\n\n  /**\n  * Sign a prepared message following web3.eth.signTypedData specification. The host computes the domain separator and hashStruct(message)\n  * @example\n  eth.signEIP712HashedMessage(\"44'/60'/0'/0/0\", Buffer.from(\"0101010101010101010101010101010101010101010101010101010101010101\").toString(\"hex\"), Buffer.from(\"0202020202020202020202020202020202020202020202020202020202020202\").toString(\"hex\")).then(result => {\n  var v = result['v'] - 27;\n  v = v.toString(16);\n  if (v.length < 2) {\n    v = \"0\" + v;\n  }\n  console.log(\"Signature 0x\" + result['r'] + result['s'] + v);\n})\n   */\n  signEIP712HashedMessage(\n    path: string,\n    domainSeparatorHex: string,\n    hashStructMessageHex: string\n  ): Promise<{\n    v: number,\n    s: string,\n    r: string,\n  }> {\n    const domainSeparator = hexBuffer(domainSeparatorHex);\n    const hashStruct = hexBuffer(hashStructMessageHex);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4 + 32 + 32, 0);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    domainSeparator.copy(buffer, offset);\n    offset += 32;\n    hashStruct.copy(buffer, offset);\n    return this.transport\n      .send(0xe0, 0x0c, 0x00, 0x00, buffer)\n      .then((response) => {\n        const v = response[0];\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { v, r, s };\n      });\n  }\n\n  /**\n   * get Stark public key for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @return the Stark public key\n   */\n  starkGetPublicKey(path: string, boolDisplay?: boolean): Promise<Buffer> {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport\n      .send(0xf0, 0x02, boolDisplay ? 0x01 : 0x00, 0x00, buffer)\n      .then((response) => {\n        return response.slice(0, response.length - 2);\n      });\n  }\n\n  /**\n   * sign a Stark order\n   * @param path a path in BIP 32 format\n   * @option sourceTokenAddress contract address of the source token (not present for ETH)\n   * @param sourceQuantization quantization used for the source token\n   * @option destinationTokenAddress contract address of the destination token (not present for ETH)\n   * @param destinationQuantization quantization used for the destination token\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountSell amount to sell\n   * @param amountBuy amount to buy\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n  starkSignOrder(\n    path: string,\n    sourceTokenAddress?: string,\n    sourceQuantization: BigNumber,\n    destinationTokenAddress?: string,\n    destinationQuantization: BigNumber,\n    sourceVault: number,\n    destinationVault: number,\n    amountSell: BigNumber,\n    amountBuy: BigNumber,\n    nonce: number,\n    timestamp: number\n  ): Promise<Buffer> {\n    const sourceTokenAddressHex = maybeHexBuffer(sourceTokenAddress);\n    const destinationTokenAddressHex = maybeHexBuffer(destinationTokenAddress);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(\n      1 + paths.length * 4 + 20 + 32 + 20 + 32 + 4 + 4 + 8 + 8 + 4 + 4,\n      0\n    );\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    if (sourceTokenAddressHex) {\n      sourceTokenAddressHex.copy(buffer, offset);\n    }\n    offset += 20;\n    Buffer.from(sourceQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 32;\n    if (destinationTokenAddressHex) {\n      destinationTokenAddressHex.copy(buffer, offset);\n    }\n    offset += 20;\n    Buffer.from(\n      destinationQuantization.toString(16).padStart(64, \"0\"),\n      \"hex\"\n    ).copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountSell.toString(16).padStart(16, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 8;\n    Buffer.from(amountBuy.toString(16).padStart(16, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport\n      .send(0xf0, 0x04, 0x01, 0x00, buffer)\n      .then((response) => {\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { r, s };\n      });\n  }\n\n  /**\n   * sign a Stark order using the Starkex V2 protocol\n   * @param path a path in BIP 32 format\n   * @option sourceTokenAddress contract address of the source token (not present for ETH)\n   * @param sourceQuantizationType quantization type used for the source token\n   * @option sourceQuantization quantization used for the source token (not present for erc 721 or mintable erc 721)\n   * @option sourceMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the source token\n   * @option destinationTokenAddress contract address of the destination token (not present for ETH)\n   * @param destinationQuantizationType quantization type used for the destination token\n   * @option destinationQuantization quantization used for the destination token (not present for erc 721 or mintable erc 721)\n   * @option destinationMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the destination token\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountSell amount to sell\n   * @param amountBuy amount to buy\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n  starkSignOrder_v2(\n    path: string,\n    sourceTokenAddress?: string,\n    sourceQuantizationType: StarkQuantizationType,\n    sourceQuantization?: BigNumber,\n    sourceMintableBlobOrTokenId?: BigNumber,\n    destinationTokenAddress?: string,\n    destinationQuantizationType: StarkQuantizationType,\n    destinationQuantization?: BigNumber,\n    destinationMintableBlobOrTokenId?: BigNumber,\n    sourceVault: number,\n    destinationVault: number,\n    amountSell: BigNumber,\n    amountBuy: BigNumber,\n    nonce: number,\n    timestamp: number\n  ): Promise<Buffer> {\n    const sourceTokenAddressHex = maybeHexBuffer(sourceTokenAddress);\n    const destinationTokenAddressHex = maybeHexBuffer(destinationTokenAddress);\n    if (!(sourceQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\n        \"eth.starkSignOrderv2 invalid source quantization type=\" +\n          sourceQuantizationType\n      );\n    }\n    if (!(destinationQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\n        \"eth.starkSignOrderv2 invalid destination quantization type=\" +\n          destinationQuantizationType\n      );\n    }\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(\n      1 +\n        paths.length * 4 +\n        1 +\n        20 +\n        32 +\n        32 +\n        1 +\n        20 +\n        32 +\n        32 +\n        4 +\n        4 +\n        8 +\n        8 +\n        4 +\n        4,\n      0\n    );\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    buffer[offset] = starkQuantizationTypeMap[sourceQuantizationType];\n    offset++;\n    if (sourceTokenAddressHex) {\n      sourceTokenAddressHex.copy(buffer, offset);\n    }\n    offset += 20;\n    if (sourceQuantization) {\n      Buffer.from(\n        sourceQuantization.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    if (sourceMintableBlobOrTokenId) {\n      Buffer.from(\n        sourceMintableBlobOrTokenId.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    buffer[offset] = starkQuantizationTypeMap[destinationQuantizationType];\n    offset++;\n    if (destinationTokenAddressHex) {\n      destinationTokenAddressHex.copy(buffer, offset);\n    }\n    offset += 20;\n    if (destinationQuantization) {\n      Buffer.from(\n        destinationQuantization.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    if (destinationMintableBlobOrTokenId) {\n      Buffer.from(\n        destinationMintableBlobOrTokenId.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountSell.toString(16).padStart(16, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 8;\n    Buffer.from(amountBuy.toString(16).padStart(16, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport\n      .send(0xf0, 0x04, 0x03, 0x00, buffer)\n      .then((response) => {\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { r, s };\n      });\n  }\n\n  /**\n   * sign a Stark transfer\n   * @param path a path in BIP 32 format\n   * @option transferTokenAddress contract address of the token to be transferred (not present for ETH)\n   * @param transferQuantization quantization used for the token to be transferred\n   * @param targetPublicKey target Stark public key\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountTransfer amount to transfer\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n  starkSignTransfer(\n    path: string,\n    transferTokenAddress?: string,\n    transferQuantization: BigNumber,\n    targetPublicKey: string,\n    sourceVault: number,\n    destinationVault: number,\n    amountTransfer: BigNumber,\n    nonce: number,\n    timestamp: number\n  ): Promise<Buffer> {\n    const transferTokenAddressHex = maybeHexBuffer(transferTokenAddress);\n    const targetPublicKeyHex = hexBuffer(targetPublicKey);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(\n      1 + paths.length * 4 + 20 + 32 + 32 + 4 + 4 + 8 + 4 + 4,\n      0\n    );\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    if (transferTokenAddressHex) {\n      transferTokenAddressHex.copy(buffer, offset);\n    }\n    offset += 20;\n    Buffer.from(\n      transferQuantization.toString(16).padStart(64, \"0\"),\n      \"hex\"\n    ).copy(buffer, offset);\n    offset += 32;\n    targetPublicKeyHex.copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountTransfer.toString(16).padStart(16, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport\n      .send(0xf0, 0x04, 0x02, 0x00, buffer)\n      .then((response) => {\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { r, s };\n      });\n  }\n\n  /**\n   * sign a Stark transfer or conditional transfer using the Starkex V2 protocol\n   * @param path a path in BIP 32 format\n   * @option transferTokenAddress contract address of the token to be transferred (not present for ETH)\n   * @param transferQuantizationType quantization type used for the token to be transferred\n   * @option transferQuantization quantization used for the token to be transferred (not present for erc 721 or mintable erc 721)\n   * @option transferMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the token to be transferred\n   * @param targetPublicKey target Stark public key\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountTransfer amount to transfer\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @option conditionalTransferAddress onchain address of the condition for a conditional transfer\n   * @option conditionalTransferFact fact associated to the condition for a conditional transfer\n   * @return the signature\n   */\n  starkSignTransfer_v2(\n    path: string,\n    transferTokenAddress?: string,\n    transferQuantizationType: StarkQuantizationType,\n    transferQuantization?: BigNumber,\n    transferMintableBlobOrTokenId?: BigNumber,\n    targetPublicKey: string,\n    sourceVault: number,\n    destinationVault: number,\n    amountTransfer: BigNumber,\n    nonce: number,\n    timestamp: number,\n    conditionalTransferAddress?: string,\n    conditionalTransferFact?: BigNumber\n  ): Promise<Buffer> {\n    const transferTokenAddressHex = maybeHexBuffer(transferTokenAddress);\n    const targetPublicKeyHex = hexBuffer(targetPublicKey);\n    const conditionalTransferAddressHex = maybeHexBuffer(\n      conditionalTransferAddress\n    );\n    if (!(transferQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\n        \"eth.starkSignTransferv2 invalid quantization type=\" +\n          transferQuantizationType\n      );\n    }\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(\n      1 +\n        paths.length * 4 +\n        1 +\n        20 +\n        32 +\n        32 +\n        32 +\n        4 +\n        4 +\n        8 +\n        4 +\n        4 +\n        (conditionalTransferAddressHex ? 32 + 20 : 0),\n      0\n    );\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    buffer[offset] = starkQuantizationTypeMap[transferQuantizationType];\n    offset++;\n    if (transferTokenAddressHex) {\n      transferTokenAddressHex.copy(buffer, offset);\n    }\n    offset += 20;\n    if (transferQuantization) {\n      Buffer.from(\n        transferQuantization.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    if (transferMintableBlobOrTokenId) {\n      Buffer.from(\n        transferMintableBlobOrTokenId.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    targetPublicKeyHex.copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountTransfer.toString(16).padStart(16, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    if (conditionalTransferAddressHex && conditionalTransferFact) {\n      offset += 4;\n      Buffer.from(\n        conditionalTransferFact.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n      offset += 32;\n      conditionalTransferAddressHex.copy(buffer, offset);\n    }\n    return this.transport\n      .send(\n        0xf0,\n        0x04,\n        conditionalTransferAddressHex ? 0x05 : 0x04,\n        0x00,\n        buffer\n      )\n      .then((response) => {\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { r, s };\n      });\n  }\n\n  /**\n   * provide quantization information before singing a deposit or withdrawal Stark powered contract call\n   *\n   * It shall be run following a provideERC20TokenInformation call for the given contract\n   *\n   * @param operationContract contract address of the token to be transferred (not present for ETH)\n   * @param operationQuantization quantization used for the token to be transferred\n   */\n  starkProvideQuantum(\n    operationContract?: string,\n    operationQuantization: BigNumber\n  ): Promise<boolean> {\n    const operationContractHex = maybeHexBuffer(operationContract);\n    let buffer = Buffer.alloc(20 + 32, 0);\n    if (operationContractHex) {\n      operationContractHex.copy(buffer, 0);\n    }\n    Buffer.from(\n      operationQuantization.toString(16).padStart(64, \"0\"),\n      \"hex\"\n    ).copy(buffer, 20);\n    return this.transport.send(0xf0, 0x08, 0x00, 0x00, buffer).then(\n      () => true,\n      (e) => {\n        if (e && e.statusCode === 0x6d00) {\n          // this case happen for ETH application versions not supporting Stark extensions\n          return false;\n        }\n        throw e;\n      }\n    );\n  }\n\n  /**\n   * provide quantization information before singing a deposit or withdrawal Stark powered contract call using the Starkex V2 protocol\n   *\n   * It shall be run following a provideERC20TokenInformation call for the given contract\n   *\n   * @param operationContract contract address of the token to be transferred (not present for ETH)\n   * @param operationQuantizationType quantization type of the token to be transferred\n   * @option operationQuantization quantization used for the token to be transferred (not present for erc 721 or mintable erc 721)\n   * @option operationMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) of the token to be transferred\n   */\n  starkProvideQuantum_v2(\n    operationContract?: string,\n    operationQuantizationType: StarkQuantizationType,\n    operationQuantization?: BigNumber,\n    operationMintableBlobOrTokenId?: BigNumber\n  ): Promise<boolean> {\n    const operationContractHex = maybeHexBuffer(operationContract);\n    if (!(operationQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\n        \"eth.starkProvideQuantumV2 invalid quantization type=\" +\n          operationQuantizationType\n      );\n    }\n    let buffer = Buffer.alloc(20 + 32 + 32, 0);\n    let offset = 0;\n    if (operationContractHex) {\n      operationContractHex.copy(buffer, offset);\n    }\n    offset += 20;\n    if (operationQuantization) {\n      Buffer.from(\n        operationQuantization.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    if (operationMintableBlobOrTokenId) {\n      Buffer.from(\n        operationMintableBlobOrTokenId.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    return this.transport\n      .send(\n        0xf0,\n        0x08,\n        starkQuantizationTypeMap[operationQuantizationType],\n        0x00,\n        buffer\n      )\n      .then(\n        () => true,\n        (e) => {\n          if (e && e.statusCode === 0x6d00) {\n            // this case happen for ETH application versions not supporting Stark extensions\n            return false;\n          }\n          throw e;\n        }\n      );\n  }\n\n  /**\n   * sign the given hash over the Stark curve\n   * It is intended for speed of execution in case an unknown Stark model is pushed and should be avoided as much as possible.\n   * @param path a path in BIP 32 format\n   * @param hash hexadecimal hash to sign\n   * @return the signature\n   */\n  starkUnsafeSign(path: string, hash: string): Promise<Buffer> {\n    const hashHex = hexBuffer(hash);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4 + 32);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    hashHex.copy(buffer, offset);\n    return this.transport\n      .send(0xf0, 0x0a, 0x00, 0x00, buffer)\n      .then((response) => {\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { r, s };\n      });\n  }\n\n  /**\n   * get an Ethereum 2 BLS-12 381 public key for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @return an object with a publicKey\n   * @example\n   * eth.eth2GetPublicKey(\"12381/3600/0/0\").then(o => o.publicKey)\n   */\n  eth2GetPublicKey(\n    path: string,\n    boolDisplay?: boolean\n  ): Promise<{\n    publicKey: string,\n  }> {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport\n      .send(0xe0, 0x0e, boolDisplay ? 0x01 : 0x00, 0x00, buffer)\n      .then((response) => {\n        let result = {};\n        result.publicKey = response.slice(0, -2).toString(\"hex\");\n        return result;\n      });\n  }\n\n  /**\n   * Set the index of a Withdrawal key used as withdrawal credentials in an ETH 2 deposit contract call signature\n   *\n   * It shall be run before the ETH 2 deposit transaction is signed. If not called, the index is set to 0\n   *\n   * @param withdrawalIndex index path in the EIP 2334 path m/12381/3600/withdrawalIndex/0\n   * @return True if the method was executed successfully\n   */\n  eth2SetWithdrawalIndex(withdrawalIndex: number): Promise<boolean> {\n    let buffer = Buffer.alloc(4, 0);\n    buffer.writeUInt32BE(withdrawalIndex, 0);\n    return this.transport.send(0xe0, 0x10, 0x00, 0x00, buffer).then(\n      () => true,\n      (e) => {\n        if (e && e.statusCode === 0x6d00) {\n          // this case happen for ETH application versions not supporting ETH 2\n          return false;\n        }\n        throw e;\n      }\n    );\n  }\n\n  /**\n   * Set the name of the plugin that should be used to parse the next transaction\n   *\n   * @param pluginName string containing the name of the plugin, must have length between 1 and 30 bytes\n   * @return True if the method was executed successfully\n   */\n  setExternalPlugin(\n    pluginName: string,\n    contractAddress: string,\n    selector: string\n  ): Promise<boolean> {\n    return setExternalPlugin(this.transport, pluginName, selector);\n  }\n}\n\n// internal helpers\n\nfunction provideERC20TokenInformation(\n  transport: Transport<*>,\n  data: Buffer\n): Promise<boolean> {\n  return transport.send(0xe0, 0x0a, 0x00, 0x00, data).then(\n    () => true,\n    (e) => {\n      if (e && e.statusCode === 0x6d00) {\n        // this case happen for older version of ETH app, since older app version had the ERC20 data hardcoded, it's fine to assume it worked.\n        // we return a flag to know if the call was effective or not\n        return false;\n      }\n      throw e;\n    }\n  );\n}\n\nfunction setExternalPlugin(\n  transport: Transport<*>,\n  payload: string,\n  signature: string\n): Promise<boolean> {\n  let payloadBuffer = Buffer.from(payload, \"hex\");\n  let signatureBuffer = Buffer.from(signature, \"hex\");\n  let buffer = Buffer.concat([payloadBuffer, signatureBuffer]);\n  return transport.send(0xe0, 0x12, 0x00, 0x00, buffer).then(\n    () => true,\n    (e) => {\n      if (e && e.statusCode === 0x6a80) {\n        // this case happen when the plugin name is too short or too long\n        return false;\n      } else if (e && e.statusCode === 0x6984) {\n        // this case happen when the plugin requested is not installed on the device\n        return false;\n      } else if (e && e.statusCode === 0x6d00) {\n        // this case happen for older version of ETH app\n        return false;\n      }\n      throw e;\n    }\n  );\n}\n"],"file":"Eth.js"}